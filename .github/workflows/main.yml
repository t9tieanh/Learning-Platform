name: Build & Deploy Microservices to VPS

on:
  push:
    branches:
      - feature/test_ci_cd
  pull_request:
    branches:
      - feature/test_ci_cd

env:
  REGISTRY: docker.io
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  API_GATEWAY_IMAGE: learnova_api-gateway
  USER_SERVICE_IMAGE: learnova_user-service
  COURSE_SERVICE_IMAGE: learnova_course-service
  SALE_SERVICE_IMAGE: learnova_sale-service
  NOTIFICATION_SERVICE_IMAGE: learnova_notification-service
  SOCKET_SERVER_IMAGE: learnova_socket-server

jobs:
  # Check which services changed
  changes:
    runs-on: ubuntu-latest
    outputs:
      api-gateway: ${{ steps.changes.outputs.api-gateway }}
      user-service: ${{ steps.changes.outputs.user-service }}
      course-service: ${{ steps.changes.outputs.course-service }}
      sale-service: ${{ steps.changes.outputs.sale-service }}
      notification-service: ${{ steps.changes.outputs.notification-service }}
      socket-server: ${{ steps.changes.outputs.socket-server }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check file changes
        id: changes
        run: |
          # Get the list of changed files
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})
          else
            # Handle initial commit or when github.event.before is empty
            if [[ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" || -z "${{ github.event.before }}" ]]; then
              # For initial push, get all files from the commit
              CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r ${{ github.event.after }})
            else
              # Normal push - compare with previous commit
              CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.event.after }})
            fi
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Check each service
          echo "api-gateway=$(echo "$CHANGED_FILES" | grep -q 'rest-api/api-gateway' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "user-service=$(echo "$CHANGED_FILES" | grep -q 'rest-api/user-service' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "course-service=$(echo "$CHANGED_FILES" | grep -q 'rest-api/course-service' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "sale-service=$(echo "$CHANGED_FILES" | grep -q 'rest-api/sale-service' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "notification-service=$(echo "$CHANGED_FILES" | grep -q 'rest-api/notification-service' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "socket-server=$(echo "$CHANGED_FILES" | grep -q 'socket-server' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT

  # Build all microservices
  build:
    needs: changes
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    strategy:
      matrix:
        service:
          - api-gateway
          - user-service
          - course-service
          - sale-service
          - notification-service
          - socket-server

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image - ${{ matrix.service }}
        uses: docker/build-push-action@v5
        if: needs.changes.outputs[matrix.service] == 'true'
        env:
          IMAGE_NAME: ${{ env[format('{0}_IMAGE', matrix.service == 'api-gateway' && 'API_GATEWAY' || matrix.service == 'user-service' && 'USER_SERVICE' || matrix.service == 'course-service' && 'COURSE_SERVICE' || matrix.service == 'sale-service' && 'SALE_SERVICE' || matrix.service == 'notification-service' && 'NOTIFICATION_SERVICE' || 'SOCKET_SERVER')] }}
          BUILD_CONTEXT: ${{ matrix.service == 'socket-server' && '.' || './rest-api' }}
          DOCKERFILE_PATH: ${{ matrix.service == 'socket-server' && 'socket-server/Dockerfile' || format('rest-api/{0}/Dockerfile', matrix.service) }}
        with:
          context: ${{ env.BUILD_CONTEXT }}
          file: ${{ env.DOCKERFILE_PATH }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
            ${{ env.REGISTRY }}/${{ env.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Skip build - ${{ matrix.service }}
        if: needs.changes.outputs[matrix.service] == 'false'
        run: echo "‚è≠Ô∏è  Skipped building ${{ matrix.service }} (no changes detected)"

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/feature/test_ci_cd' && github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -p ${{ secrets.VPS_SSH_PORT }} ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Deploy to VPS
        run: |
          ssh -i ~/.ssh/deploy_key -p ${{ secrets.VPS_SSH_PORT }} ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'DEPLOY_EOF'
            set -e
            
            # Cleanup function - runs on success or failure
            cleanup() {
              echo "üßπ Cleaning up production folder..."
              cd ~
              rm -rf ~/learning-platform/production
              echo "‚úÖ Production folder cleaned up!"
            }
            
            # Register cleanup to run on exit (both success and error)
            trap cleanup EXIT
            
            # Create production folder if it doesn't exist
            mkdir -p ~/learning-platform/production
            cd ~/learning-platform/production || exit 1
            
            echo "üîÑ Creating environment files from secrets..."
            
            # API Gateway config
            cat > api-gateway.application.yaml << 'YAML_EOF'
            ${{ secrets.PROD_API_GATEWAY_CONFIG_YAML }}
            YAML_EOF
            
            # Course Service config
            cat > course-service.application.yaml << 'YAML_EOF'
            ${{ secrets.PROD_COURSE_SERVICE_CONFIG_YAML }}
            YAML_EOF
            
            # User Service config
            cat > user-service.application.yaml << 'YAML_EOF'
            ${{ secrets.PROD_USER_SERVICE_CONFIG_YAML }}
            YAML_EOF
            
            # Sale Service .env
            cat > sale-service.env << 'ENV_EOF'
            ${{ secrets.PROD_SALE_SERVICE_ENV }}
            ENV_EOF
            
            # Notification Service .env
            cat > notification-service.env << 'ENV_EOF'
            ${{ secrets.PROD_NOTIFICATION_SERVICE_ENV }}
            ENV_EOF
            
            # CloudFront private key
            cat > cloudfront-private-key.pem << 'KEY_EOF'
            ${{ secrets.AWS_CLOUDFRONT_PRIVATE_KEY_PEM }}
            KEY_EOF
            chmod 600 cloudfront-private-key.pem
            
            cat > .env << 'ENV_EOF'
            ${{ secrets.PROD_DOCKER_COMPOSE_ENV }}
            ENV_EOF

            echo "üöÄ Pulling latest Docker images..."
            docker pull ${{ env.REGISTRY }}/${{ env.DOCKERHUB_USERNAME }}/${{ env.API_GATEWAY_IMAGE }}:latest
            docker pull ${{ env.REGISTRY }}/${{ env.DOCKERHUB_USERNAME }}/${{ env.USER_SERVICE_IMAGE }}:latest
            docker pull ${{ env.REGISTRY }}/${{ env.DOCKERHUB_USERNAME }}/${{ env.COURSE_SERVICE_IMAGE }}:latest
            docker pull ${{ env.REGISTRY }}/${{ env.DOCKERHUB_USERNAME }}/${{ env.SALE_SERVICE_IMAGE }}:latest
            docker pull ${{ env.REGISTRY }}/${{ env.DOCKERHUB_USERNAME }}/${{ env.NOTIFICATION_SERVICE_IMAGE }}:latest
            docker pull ${{ env.REGISTRY }}/${{ env.DOCKERHUB_USERNAME }}/${{ env.SOCKET_SERVER_IMAGE }}:latest

            # echo "üõë Stopping old containers..."
            # docker compose down || true

            # echo "üöÄ Starting services with Docker Compose..."
            # docker compose up -d

            echo "‚úÖ SSH connection successful!"
            mkdir -p ~/deployment-logs
            touch ~/deployment-logs/deployment_success_$(date +%s)
            echo "Deployment LEARNOVA started at $(date)" > ~/deployment-logs/deployment.log
            
            echo "‚úÖ Deployment completed successfully!"
            echo "Container status:"
            docker compose ps
          DEPLOY_EOF

      - name: Deployment notification
        if: success()
        run: echo "‚úÖ Successfully deployed to VPS"

      - name: Deployment failed notification
        if: failure()
        run: echo "‚ùå Deployment failed"